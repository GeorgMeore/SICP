(define (make-connector)
  (let ((value #f) (informant #f) (constraints '()))
    (define (has-value?)
      informant)
    (define (set-value! new-value setter)
      (cond ((not (has-value?))
              (set! value new-value)
              (set! informant setter)
              (for-each-except setter inform-about-value))
            ((not (= value new-value))
              (error "contradiction" (list value new-value)))
            (else 'ignored)))
    (define (for-each-except exception inform)
      (define (inform-except constraint)
        (if (not (eq? constraint exception))
            (inform constraint)))
      (for-each inform-except constraints)
      'done)
    (define (forget-value! retractor)
      (cond ((eq? retractor informant)
              (set! informant #f)
              (for-each-except retractor inform-about-no-value))
            (else 'ignored)))
    (define (connect new-constraint)
      (if (not (memq new-constraint constraints))
          (set! constraints (cons new-constraint constraints)))
      (if (has-value?)
          (inform-about-value new-constraint))
      'done)
    (define (self m)
      (cond ((eq? m 'has-value?) (has-value?))
            ((eq? m 'get-value) value)
            ((eq? m 'set-value!) set-value!)
            ((eq? m 'forget-value!) forget-value!)
            ((eq? m 'connect) connect)
            (else (error "bad message" m))))
    self))

(define (has-value? conn)
  (conn 'has-value?))

(define (get-value conn)
  (conn 'get-value))

(define (set-value! conn new-value informant)
  ((conn 'set-value!) new-value informant))

(define (forget-value! conn retractor)
  ((conn 'forget-value!) retractor))

(define (connect conn new-constraint)
  ((conn 'connect) new-constraint))
