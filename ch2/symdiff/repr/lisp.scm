; lisp's parenthesized prefix representation
; TODO: move all reductions to reduce.scm

(define variable? symbol?)
(define same-variable? eq?)

(define (=number? e n)
	(and (number? e) (= e n))
)
(define (eq-car? e s)
	(and (pair? e) (eq? (car e) s))
)

(define (make-sum . terms)
	(let ((reduced (sum-reduce terms)))
		(if (null? (cdr reduced))
			(car reduced)
			(cons '+ reduced)
		)
	)
)
(define (sum? e) (eq-car? e '+))
(define (addend s) (cadr s))
(define (augend s)
	(if (null? (cdddr s))
		(caddr s)
		(cons '+ (cddr s))
	)
)

(define (make-product . terms)
	(let ((reduced (product-reduce terms)))
		(if (null? (cdr reduced))
			(car reduced)
			(cons '* reduced)
		)
	)
)
(define (product? e) (eq-car? e '*))
(define (multiplier p) (cadr p))
(define (multiplicand p)
	(if (null? (cdddr p))
		(caddr p)
		(cons '* (cddr p))
	)
)

(define (make-exponentiation b e)
	(if (not (number? e))
		(error "number expected" e)
	)
	(cond
		((= e 0) 1)
		((= e 1) b)
		((number? b) (expt b e))
		(else (list '** b e))
	)
)
(define (exponentiation? e) (eq-car? e '**))
(define (base e) (cadr e))
(define (exponent e) (caddr e))
