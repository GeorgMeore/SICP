(define (false? x)
  (eq? x 'false))


(define (op+ . args)
  (define (check nums)
    (cond ((null? nums) (apply + args))
          ((number? (car nums))
            (check (cdr nums)))
          (else (error "Not a number" (car nums)))))
  (check args))

(define (op- . args)
  (define (check nums)
    (cond ((null? nums) (apply - args))
          ((number? (car nums))
            (check (cdr nums)))
          (else (error "Not a number" (car nums)))))
  (check args))

(define (op* . args)
  (define (check nums)
    (cond ((null? nums) (apply * args))
          ((number? (car nums))
            (check (cdr nums)))
          (else (error "Not a number" (car nums)))))
  (check args))

(define (op/ . args)
  (define (check nums)
    (cond ((null? nums) (apply / args))
          ((number? (car nums))
            (if (= (car nums) 0)
                (error "Zero division error")
                (check (cdr nums))))
          (else (error "Not a number" (car nums)))))
  (if (null? args)
      (error "Too few arguments supplied")
      (check args)))

(define (op-mod . args)
  (let ((argc (length args)))
    (if (= argc 2)
        (let ((first (car args)) (second (cadr args)))
          (cond ((not (integer? first))
                  (error "Not an integer" first))
                ((not (integer? second))
                  (error "Not an integer" second))
                ((= second 0)
                  (error "Zero division error"))
                (else
                  (remainder first second))))
        (if (> argc 2)
            (error "Too many arguments supplied")
            (error "Too few arguments supplied")))))

(define (op= . args)
  (define (check nums)
    (cond ((null? nums)
            (if (apply = args) 'true 'false))
          ((number? (car nums))
            (check (cdr nums)))
          (else (error "Not a number" (car nums)))))
  (check args))

(define (op> . args)
  (define (check nums)
    (cond ((null? nums)
            (if (apply > args) 'true 'false))
          ((number? (car nums))
            (check (cdr nums)))
          (else (error "Not a number" (car nums)))))
  (check args))

(define (op< . args)
  (define (check nums)
    (cond ((null? nums)
            (if (apply < args) 'true 'false))
          ((number? (car nums))
            (check (cdr nums)))
          (else (error "Not a number" (car nums)))))
  (check args))

(define (op-cons . args)
  (let ((argc (length args)))
    (if (= argc 2)
        (cons (car args) (cadr args))
        (if (> argc 2)
            (error "Too many arguments supplied")
            (error "Too few arguments supplied")))))

(define (op-car . args)
  (let ((argc (length args)))
    (if (= argc 1)
        (if (pair? (car args))
            (car (car args))
            (error "Not a pair" (car args)))
        (if (> argc 1)
            (error "Too many arguments supplied")
            (error "Too few arguments supplied")))))

(define (op-cdr . args)
  (let ((argc (length args)))
    (if (= argc 1)
        (if (pair? (car args))
            (cdr (car args))
            (error "Not a pair" (car args)))
        (if (> argc 1)
            (error "Too many arguments supplied")
            (error "Too few arguments supplied")))))

(define (op-null? . args)
  (let ((argc (length args)))
    (if (= argc 1)
        (if (null? (car args)) 'true 'false)
        (if (> argc 1)
            (error "Too many arguments supplied")
            (error "Too few arguments supplied")))))

(define (op-eq? . args)
  (let ((argc (length args)))
    (if (= argc 2)
        (if (eq? (car args) (cadr args)) 'true 'false)
        (if (> argc 2)
            (error "Too many arguments supplied")
            (error "Too few arguments supplied")))))

(define (op-not . args)
  (let ((argc (length args)))
    (if (= argc 1)
        (if (eq? (car args) 'false) 'true 'false)
        (if (> argc 1)
            (error "Too many arguments supplied")
            (error "Too few arguments supplied")))))

(define (op-print . args)
  (for-each
    (lambda (arg)
      (display-object arg))
    args)
  'ok)

(define (op-println . args)
  (for-each
    (lambda (arg)
      (display-object arg))
    args)
  (newline)
  'ok)

(define primitive-procedures
  (list
    (cons '+ op+)
    (cons '- op-)
    (cons '* op*)
    (cons '/ op/)
    (cons 'mod op-mod)
    (cons '= op=)
    (cons '> op>)
    (cons '< op<)
    (cons 'not op-not)
    (cons 'cons op-cons)
    (cons 'car op-car)
    (cons 'cdr op-cdr)
    (cons 'null? op-null?)
    (cons 'eq? op-eq?)
    (cons 'print op-print)
    (cons 'println op-println)
  ))

(define (primitive-procedure-names)
  (map car primitive-procedures))

(define (primitive-procedure-objects)
  (map (lambda (proc) (list 'primitive (cdr proc)))
       primitive-procedures))

(define (apply-primitive-procedure proc args)
  (apply (cadr proc) args))

(define (primitive-procedure? proc)
  (tagged-list? proc 'primitive))

(define (compiled-procedure? proc)
  (tagged-list? proc 'compiled-procedure))

(define (make-compiled-procedure entry env)
  (list 'compiled-procedure entry env))

(define (compiled-procedure-entry proc)
  (cadr proc))
(define (compiled-procedure-environment proc)
  (caddr proc))


(define (make-frame vars vals)
  (cond ((and (null? vars) (null? vals))
          '((* *))) ; empty frame
        ((null? vars)
          (error "Too many arguments supplied"))
        ((null? vals)
          (error "Too few arguments supplied"))
        (else
          (cons (cons (car vars) (car vals))
                (make-frame (cdr vars) (cdr vals))))))

(define (add-binding! var val frame)
  (set-cdr! frame (cons (car frame) (cdr frame)))
  (set-car! frame (cons var val)))

(define (get-binding var frame)
  (cond ((null? (cdr frame)) '())
        ((eq? (caar frame) var)
          (car frame))
        (else
          (get-binding var (cdr frame)))))

(define the-empty-environment
  '())

(define (first-frame env)
  (car env))
(define (enclosing-environment env)
  (cdr env))

(define (extend-environment vars vals base-env)
  (cons (make-frame vars vals) base-env))

(define (scan-environment var env found not-found)
  (define (loop env)
    (if (eq? env the-empty-environment)
        (not-found)
        (let ((binding (get-binding var (first-frame env))))
          (if (null? binding)
              (loop (enclosing-environment env))
              (found binding)))))
  (loop env))

(define (lookup-variable-value var env)
  (scan-environment var env
    (lambda (binding)
      (cdr binding))
    (lambda ()
      (error "Unbound variable" var))))

(define (set-variable-value! var val env)
  (scan-environment var env
    (lambda (binding)
      (set-cdr! binding val))
    (lambda ()
      (error "Unbound variable" var))))

(define (define-variable! var val env)
  (let ((binding (get-binding var (first-frame env))))
    (if (null? binding)
        (add-binding! var val (first-frame env))
        (set-cdr! binding val))))

(define (setup-environment)
  (let ((initial-environment
         (extend-environment (primitive-procedure-names)
                             (primitive-procedure-objects)
                             the-empty-environment)))
    (define-variable! 'true 'true initial-environment)
    (define-variable! 'false 'false initial-environment)
    (define-variable! 'nil '() initial-environment)
    initial-environment))


(define (display-object obj)
  (if (compiled-procedure? obj)
    (display (list 'procedure (procedure-parameters obj)))
    (display obj)))
