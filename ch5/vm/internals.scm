(define (false? x)
  (eq? x 'false))


(define (proc+ . args)
  (define (check nums)
    (cond ((null? nums) (apply + args))
          ((number? (car nums))
            (check (cdr nums)))
          (else (error "Not a number" (car nums)))))
  (check args))

(define (proc- . args)
  (define (check nums)
    (cond ((null? nums) (apply - args))
          ((number? (car nums))
            (check (cdr nums)))
          (else (error "Not a number" (car nums)))))
  (check args))

(define (proc* . args)
  (define (check nums)
    (cond ((null? nums) (apply * args))
          ((number? (car nums))
            (check (cdr nums)))
          (else (error "Not a number" (car nums)))))
  (check args))

(define (proc/ . args)
  (define (check nums)
    (cond ((null? nums) (apply / args))
          ((number? (car nums))
            (if (= (car nums) 0)
                (error "Zero division error")
                (check (cdr nums))))
          (else (error "Not a number" (car nums)))))
  (if (null? args)
      (error "Too few arguments supplied")
      (check args)))

(define (proc-mod . args)
  (let ((argc (length args)))
    (if (= argc 2)
        (let ((first (car args)) (second (cadr args)))
          (cond ((not (integer? first))
                  (error "Not an integer" first))
                ((not (integer? second))
                  (error "Not an integer" second))
                ((= second 0)
                  (error "Zero division error"))
                (else
                  (remainder first second))))
        (if (> argc 2)
            (error "Too many arguments supplied")
            (error "Too few arguments supplied")))))

(define (proc= . args)
  (define (check nums)
    (cond ((null? nums)
            (if (apply = args) 'true 'false))
          ((number? (car nums))
            (check (cdr nums)))
          (else (error "Not a number" (car nums)))))
  (check args))

(define (proc> . args)
  (define (check nums)
    (cond ((null? nums)
            (if (apply > args) 'true 'false))
          ((number? (car nums))
            (check (cdr nums)))
          (else (error "Not a number" (car nums)))))
  (check args))

(define (proc< . args)
  (define (check nums)
    (cond ((null? nums)
            (if (apply < args) 'true 'false))
          ((number? (car nums))
            (check (cdr nums)))
          (else (error "Not a number" (car nums)))))
  (check args))

(define (proc-cons . args)
  (let ((argc (length args)))
    (if (= argc 2)
        (cons (car args) (cadr args))
        (if (> argc 2)
            (error "Too many arguments supplied")
            (error "Too few arguments supplied")))))

(define (proc-car . args)
  (let ((argc (length args)))
    (if (= argc 1)
        (if (pair? (car args))
            (car (car args))
            (error "Not a pair" (car args)))
        (if (> argc 1)
            (error "Too many arguments supplied")
            (error "Too few arguments supplied")))))

(define (proc-cdr . args)
  (let ((argc (length args)))
    (if (= argc 1)
        (if (pair? (car args))
            (cdr (car args))
            (error "Not a pair" (car args)))
        (if (> argc 1)
            (error "Too many arguments supplied")
            (error "Too few arguments supplied")))))

(define (proc-null? . args)
  (let ((argc (length args)))
    (if (= argc 1)
        (if (null? (car args)) 'true 'false)
        (if (> argc 1)
            (error "Too many arguments supplied")
            (error "Too few arguments supplied")))))

(define (proc-eq? . args)
  (let ((argc (length args)))
    (if (= argc 2)
        (if (eq? (car args) (cadr args)) 'true 'false)
        (if (> argc 2)
            (error "Too many arguments supplied")
            (error "Too few arguments supplied")))))

(define (proc-not . args)
  (let ((argc (length args)))
    (if (= argc 1)
        (if (eq? (car args) 'false) 'true 'false)
        (if (> argc 1)
            (error "Too many arguments supplied")
            (error "Too few arguments supplied")))))

(define (proc-print . args)
  (for-each
    (lambda (arg)
      (display-object arg))
    args)
  'ok)

(define (proc-println . args)
  (for-each
    (lambda (arg)
      (display-object arg))
    args)
  (newline)
  'ok)

(define primitive-procedures
  (list
    (cons '+ proc+)
    (cons '- proc-)
    (cons '* proc*)
    (cons '/ proc/)
    (cons 'mod proc-mod)
    (cons '= proc=)
    (cons '> proc>)
    (cons '< proc<)
    (cons 'not proc-not)
    (cons 'cons proc-cons)
    (cons 'car proc-car)
    (cons 'cdr proc-cdr)
    (cons 'null? proc-null?)
    (cons 'eq? proc-eq?)
    (cons 'print proc-print)
    (cons 'println proc-println)
  ))

(define (primitive-procedure-names)
  (map car primitive-procedures))

(define (primitive-procedure-objects)
  (map (lambda (proc) (list 'primitive (cdr proc)))
       primitive-procedures))

(define (apply-primitive-procedure proc args)
  (apply (cadr proc) args))

(define (primitive-procedure? proc)
  (tagged-list? proc 'primitive))

(define (compiled-procedure? proc)
  (tagged-list? proc 'compiled-procedure))

(define (make-compiled-procedure entry env)
  (list 'compiled-procedure entry env))

(define (compiled-procedure-entry proc)
  (cadr proc))
(define (compiled-procedure-environment proc)
  (caddr proc))

(define (assert-procedure obj)
  (or (primitive-procedure? obj)
      (compiled-procedure? obj)
      (error "Not a procedure" obj)))


(define (make-frame vars vals)
  (cond ((and (null? vars) (null? vals))
          '((* *))) ; empty frame
        ((null? vars)
          (error "Too many arguments supplied"))
        ((null? vals)
          (error "Too few arguments supplied"))
        (else
          (cons (cons (car vars) (car vals))
                (make-frame (cdr vars) (cdr vals))))))

(define (add-binding! var val frame)
  (set-cdr! frame (cons (car frame) (cdr frame)))
  (set-car! frame (cons var val)))

(define (get-binding var frame)
  (cond ((null? (cdr frame)) '())
        ((eq? (caar frame) var)
          (car frame))
        (else
          (get-binding var (cdr frame)))))

(define the-empty-environment '())

(define (first-frame env)
  (car env))
(define (enclosing-environment env)
  (cdr env))

(define (extend-environment vars vals base-env)
  (cons (make-frame vars vals) base-env))

(define (lookup-variable-value var global-env)
  (let ((binding (get-binding var (first-frame global-env))))
    (if (null? binding)
        (error "Unbound variable" var)
        (cdr binding))))

(define (set-variable-value! var val global-env)
  (let ((binding (get-binding var (first-frame global-env))))
    (if (null? binding)
        (error "Unbound variable" var)
        (set-cdr! binding val))))

(define (lexical-address-lookup addr env)
  (let ((env-index (car addr)) (frame-index (cadr addr)))
    (let ((binding (list-ref (list-ref env env-index) frame-index)))
      (cdr binding))))

(define (lexical-address-set! addr val env)
  (let ((env-index (car addr)) (frame-index (cadr addr)))
    (let ((binding (list-ref (list-ref env env-index) frame-index)))
      (set-cdr! binding val))))

(define (define-variable! var val env)
  (let ((binding (get-binding var (first-frame env))))
    (if (null? binding)
        (add-binding! var val (first-frame env))
        (set-cdr! binding val))))

(define (setup-environment)
  (let ((initial-environment
         (extend-environment (primitive-procedure-names)
                             (primitive-procedure-objects)
                             the-empty-environment)))
    (define-variable! 'true 'true initial-environment)
    (define-variable! 'false 'false initial-environment)
    (define-variable! 'nil '() initial-environment)
    initial-environment))


(define (display-object obj)
  (if (compiled-procedure? obj)
    (display (list 'procedure))
    (display obj)))
